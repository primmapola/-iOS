#iOS_Platform
В Swift замыкания (или closures) — это самостоятельные блоки кода, которые могут быть переданы и использованы в коде как значения. Замыкания в Swift похожи на лямбды в других языках программирования и на блоки в Objective-C.

Замыкания могут захватывать и хранить ссылки на любые константы и переменные из контекста, в котором они определены. Это называется замыканием или захватом переменных.

Давайте рассмотрим основные аспекты замыканий в Swift:

### Синтаксис замыканий:

Базовый синтаксис замыкания выглядит следующим образом:

```swift
{ (параметры) -> тип_возвращаемого_значения in
    // код замыкания
}
```

Пример:

```swift
let sumClosure = { (a: Int, b: Int) -> Int in
    return a + b
}
print(sumClosure(5, 3))  // Вывод: 8
```

### Инференция типов:

Swift автоматически определяет типы параметров и возвращаемого значения на основе контекста, что позволяет упростить синтаксис:

```swift
let squaredClosure = { number in
    return number * number
}
print(squaredClosure(5))  // Вывод: 25
```

### Сокращенная запись:

Вы можете использовать сокращенные имена параметров, предоставляемые Swift (`$0`, `$1`, `$2` и т. д.), чтобы сделать код замыкания еще короче:

```swift
let multiplyClosure = {
    $0 * $1
}
print(multiplyClosure(5, 3))  // Вывод: 15
```

### Захват значения:

Замыкания имеют способность "захватывать" значения из окружающего их контекста:

```swift
func makeIncrementer(incrementAmount: Int) -> () -> Int {
    var total = 0
    let incrementer: () -> Int = {
        total += incrementAmount
        return total
    }
    return incrementer
}

let incrementByTwo = makeIncrementer(incrementAmount: 2)
print(incrementByTwo())  // Вывод: 2
print(incrementByTwo())  // Вывод: 4
```

### Использование замыканий:

Одним из наиболее популярных способов использования замыканий в Swift является передача их в функции высшего порядка, такие как `map()`, `filter()` и `reduce()`.

Пример:

```swift
let numbers = [1, 2, 3, 4, 5]
let squaredNumbers = numbers.map { $0 * $0 }
print(squaredNumbers)  // Вывод: [1, 4, 9, 16, 25]
```

### Замыкания и [[Capture list]]

Когда замыкание захватывает экземпляр некоторого объекта, оно также захватывает сильную ссылку (strong reference) на этот объект. Это может привести к проблемам управления памятью, таким как циклические ссылки (retain cycles). 

Циклическая ссылка происходит, когда два объекта ссылаются друг на друга сильными ссылками, и это может привести к утечке памяти, потому что оба объекта не будут освобождены из памяти, даже когда они больше не используются.

Для предотвращения циклических ссылок в замыканиях Swift предоставляет `capture list`. С помощью `capture list` вы можете определить ссылки как слабые (weak) или непрочные (unowned).

### Weak vs Unowned

- **weak**: Эта ссылка не удерживает объект в памяти, и автоматически становится `nil`, когда объект уничтожается. Она всегда является опциональной (`?`).
- **unowned**: Эта ссылка также не удерживает объект в памяти, но она не становится `nil`. Если вы пытаетесь обратиться к уничтоженному объекту через `unowned` ссылку, это вызовет ошибку времени выполнения. Она является неопциональной.

### Пример использования `weak self`:

Представьте себе класс `DataTask`, который выполняет некоторую задачу и затем вызывает замыкание:

```swift
class DataTask {
    var completionHandler: (() -> Void)?

    func fetchData() {
        // После получения данных
        completionHandler?()
    }
}

class ViewController: UIViewController {
    let dataTask = DataTask()

    func setupDataTask() {
        dataTask.completionHandler = {
            // Если бы мы написали здесь просто self.updateUI(),
            // это создало бы циклическую ссылку.
            [weak self] in 
            self?.updateUI()
        }
    }

    func updateUI() {
        // Обновление интерфейса
    }
}
```

В приведенном выше коде мы используем `[weak self]` в `capture list` замыкания, чтобы гарантировать, что замыкание захватывает слабую ссылку на `self` (то есть `ViewController`). Это предотвращает создание циклической ссылки между экземплярами `DataTask` и `ViewController`.

В целом, использование `weak self` или `unowned self` в замыканиях является распространенным приемом в Swift для предотвращения циклических ссылок и утечек памяти. Важно понимать, когда и как их использовать, чтобы обеспечивать корректное управление памятью в вашем приложении.