ARC, или Automatic Reference Counting, это механизм управления памятью в Swift, который автоматически отслеживает и управляет использованием памяти в приложении. ARC освобождает память, когда экземпляр класса больше не используется, предотвращая утечки памяти. Он работает путём подсчёта ссылок на объект: каждый раз, когда вы создаёте ссылку на объект, счётчик ссылок увеличивается, и каждый раз, когда ссылка удаляется, счётчик уменьшается. Когда счётчик достигает нуля, объект удаляется из памяти.


Automatic Reference Counting (ARC) в Swift автоматически управляет памятью, удаляя объекты, которые больше не нужны. Он отслеживает количество "сильных" ссылок на каждый объект, и когда их количество достигает нуля, объект удаляется из памяти. Вот как это работает:

### Сильные ссылки
Когда вы создаёте экземпляр класса, ARC отслеживает его, увеличивая счётчик ссылок:

```swift
class MyClass {
    var property: String
    
    init(property: String) {
        self.property = property
        print("\(property) инициализирован")
    }
    
    deinit {
        print("\(property) деинициализирован")
    }
}

var example1: MyClass? = MyClass(property: "Пример1") // Счётчик ссылок = 1
```

Когда `example1` становится `nil`, счётчик ссылок уменьшается до нуля, и объект удаляется:

```swift
example1 = nil // "Пример1 деинициализирован"
```

### Слабые ссылки
Слабые ссылки (`weak`) не увеличивают счётчик ссылок. Они используются для предотвращения циклов сильных ссылок, особенно в отношениях "родитель-ребёнок":

```swift
class Parent {
    var child: Child?
    deinit { print("Родитель деинициализирован") }
}

class Child {
    weak var parent: Parent?
    deinit { print("Ребёнок деинициализирован") }
}

var parent: Parent? = Parent()
var child: Child? = Child()

parent?.child = child
child?.parent = parent

parent = nil // "Родитель деинициализирован"
child = nil // "Ребёнок деинициализирован"
```

В этом примере, несмотря на взаимные ссылки, объекты корректно деинициализируются.

### Бесхозные ссылки
Бесхозные ссылки (`unowned`) похожи на слабые, но они всегда должны иметь значение. Используйте их, когда вы уверены, что ссылка всегда будет указывать на объект, и она не будет `nil`:

```swift
class Employee {
    var task: Task?
    deinit { print("Сотрудник деинициализирован") }
}

class Task {
    unowned var employee: Employee
    init(employee: Employee) {
        self.employee = employee
    }
    deinit { print("Задача деинициализирована") }
}

var employee: Employee? = Employee()
employee?.task = Task(employee: employee!)
employee = nil // "Сотрудник деинициализирован" и "Задача деинициализирована"
```

В этом случае, когда `employee` удаляется, связанная с ним задача (`Task`) также удаляется, несмотря на `unowned` ссылку.

### Захват в замыканиях
ARC также управляет захватом объектов в замыканиях. Если замыкание захватывает `self`, нужно быть осторожным, чтобы не создать цикл сильных ссылок:

```swift
class SampleClass {
    var property = "Свойство"
    
    func doSomething() {
        DispatchQueue.main.async {
            print(self.property)
        }
    }
    
    deinit {
        print("SampleClass деинициализирован")
    }
}

var sample: SampleClass? = SampleClass()
sample?.doSomething()
sample = nil // Может не вызвать деинициализацию, если замыкание захватило self
```

Чтобы избежать этого, используйте [weak self] или [unowned self] в замыканиях:

```swift
func do

Something() {
    DispatchQueue.main.async { [weak self] in
        print(self?.property ?? "default")
    }
}
```

Таким образом, ARC эффективно управляет памятью, автоматически удаляя объекты, которые больше не используются, предотвращая утечки памяти и избыточное использование ресурсов.