#iOS_Platform 

### 1. Статическая (Ранняя) Диспетчеризация в Swift:

Статическая диспетчеризация в Swift обычно происходит при использовании структур, перечислений и методов протокола с ограничениями типа. Пример статической диспетчеризации с использованием структур:

```swift
struct Square {
    func draw() {
        print("Рисуем квадрат")
    }
}

struct Circle {
    func draw() {
        print("Рисуем круг")
    }
}

func render(shape: Square) {
    shape.draw()
}

let square = Square()
render(shape: square)
```

В этом примере вызов функции `draw()` для объекта `square` решается на этапе компиляции. Компилятор точно знает, какую функцию `draw()` вызывать, и это решение не меняется во время выполнения.

### 2. Динамическая (Поздняя) Диспетчеризация в Swift:

Динамическая диспетчеризация обычно используется в классах и протоколах. Пример с классами:

```swift
class Shape {
    func draw() {
        print("Рисуем форму")
    }
}

class Triangle: Shape {
    override func draw() {
        print("Рисуем треугольник")
    }
}

func render(shape: Shape) {
    shape.draw()
}

let triangle = Triangle()
render(shape: triangle)
```

Здесь, несмотря на то что тип параметра функции `render()` является `Shape`, во время выполнения вызывается метод `draw()` класса `Triangle`. Это происходит благодаря динамической диспетчеризации и полиморфизму времени выполнения.

### 3. Смешанная Диспетчеризация с Протоколами в Swift:

Swift использует интересный подход к диспетчеризации с протоколами. Если метод протокола не имеет реализации по умолчанию, то он использует динамическую диспетчеризацию. Но если для метода протокола предоставлена реализация по умолчанию, то используется статическая диспетчеризация.

Пример с протоколом без реализации по умолчанию (динамическая диспетчеризация):

```swift
protocol Drawable {
    func draw()
}

class Rectangle: Drawable {
    func draw() {
        print("Рисуем прямоугольник")
    }
}

func render(shape: Drawable) {
    shape.draw()
}

let rectangle = Rectangle()
render(shape: rectangle)
```

Пример с протоколом с реализацией по умолчанию (статическая диспетчеризация):

```swift
protocol Printable {
    func printDescription()
}

extension Printable {
    func printDescription() {
        print("Это печатаемый объект")
    }
}

struct Book: Printable {
    // Не переопределяем метод printDescription
}

let book = Book()
book.printDescription()
```

В первом примере используется динамическая диспетчеризация, так как метод `draw()` не имеет реализации по умолчанию. Во втором примере метод `printDescription()` имеет реализацию по умолчанию, поэтому используется статическая диспетчеризация.

В Swift механизм диспетчеризации зависит от типов, с которыми вы работаете. Вот как различные типы диспетчеризируются в Swift:

### 1. Структуры и Перечисления (Enums)

- **Метод диспетчеризации:** Статическая
- **Описание:** Методы структур и перечислений решаются на этапе компиляции. Компилятор точно знает, какую функцию вызвать, и решение не изменяется во время выполнения.
- **Пример:**
  ```swift
  struct Rectangle {
      func draw() {
          print("Рисуем прямоугольник")
      }
  }

  let rectangle = Rectangle()
  rectangle.draw() // Статическая диспетчеризация
  ```

### 2. Классы

- **Метод диспетчеризации:** Динамическая
- **Описание:** Методы классов поддерживают динамический полиморфизм и виртуальные вызовы. Решение о том, какую функцию вызвать, принимается во время выполнения на основе фактического типа объекта.
- **Пример:**
  ```swift
  class Shape {
      func draw() {
          print("Рисуем форму")
      }
  }

  class Circle: Shape {
      override func draw() {
          print("Рисуем круг")
      }
  }

  let shape: Shape = Circle()
  shape.draw() // Динамическая диспетчеризация
  ```

### 3. Протоколы

- **Метод диспетчеризации:** Смешанный (Зависит от контекста)
- **Описание:** Если метод протокола не имеет реализации по умолчанию, используется динамическая диспетчеризация. Если же есть реализация по умолчанию, то используется статическая диспетчеризация.
- **Примеры:**
  - Динамическая:
    ```swift
    protocol Drawable {
        func draw()
    }

    class Line: Drawable {
        func draw() {
            print("Рисуем линию")
        }
    }

    let line: Drawable = Line()
    line.draw() // Динамическая диспетчеризация
    ```
  - Статическая:
    ```swift
    protocol Printable {
        func printDescription()
    }

    extension Printable {
        func printDescription() {
            print("Это печатаемый объект")
        }
    }

    struct Book: Printable {
        // Нет собственной реализации printDescription
    }

    let book = Book()
    book.printDescription() // Статическая диспетчеризация
    ```

### 4. Функции и Замыкания (Closures)

- **Метод диспетчеризации:** Обычно статическая
- **Описание:** Функции и замыкания обычно используют статическую диспетчеризацию. Однако, замыкания могут захватывать и использовать значения из своего окружения, что может влиять на их поведение во время выполнения.
- **Пример:**
  ```swift
  func add(_ a: Int, _ b: Int) -> Int {
      return a + b
  }

  let result = add(2, 3) // Статическая диспетчеризация
  ```

### Обобщение:

- **Структуры и Перечисления:** Статическая диспетчеризация
- **Классы:** Динамическая диспетчеризация
- **Протоколы:** Смешанная, зависит от наличия реализации по умолчанию
- **Функции и Замыкания:** Обычно статическая, но замыкания могут иметь особенности из-за захвата контекста

Понимание того, как работает диспетчеризация в Swift, помогает в оптимизации производительности и понимании поведения кода в различных сценариях.