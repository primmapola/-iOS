Грубо говоря, **Run Loop** - это один большой поток в приложении, который обрабатывает различные ивенты в приложении, подключения (hardware) и т.п. Так же, Run Loop управляет потоками и нагрузкой на них.

Режими Run Loop:

- Default
- Even Tracking
- Connections
- Modals
- CommonMode (объединяет в себе все режимы)

На Mac Os работают - Connections, Even Tracking, Modals и default) В iOS приложении - CommonMode, который объединяет в себе Default и EventTracking (т.к в приложении на iOS нет сторонних hardware подключений и модальных окон как на MacOS)

**Самый прикольный пример:**

Таймер в iOS приложении и его неточности. К примеру, если поток будет занят другой задачей, то он не сможет вовремя обработать таймер и тогда, таймер отработает не вовремя. Поэтому не стоит строить какую-то важную бизнес логику на таймере. Все же, чтобы таймер работал нормально, его нужно запускать на commonMode ран лупа

https://habr.com/ru/companies/otus/articles/590319/

Тут есть момент: про ScrollView - может тормозить из-за проблем в ран лупе, а именно с состоянием `UITrackingRunLoopMode`, ScrollView использует его для отслеживания касаний и слайдов, что бы гарантировать что интерфейс не зависит от других режимов при слайдинге

**В системе по умолчанию предусмотрено пять режимов:**

1. **kCFRunLoopDefaultMode**: дефолтный для вашего приложения режим, обычно в этом режиме выполняется основной (main) поток.
    
2. **UITrackingRunLoopMode**: режим отслеживания интерфейса, используемый ScrollView для отслеживания касаний и слайдов, чтобы гарантировать, что интерфейс не зависит от других режимов при слайдинге.
    
3. **UIInitializationRunLoopMode**: первый режим, в который приложение входит при запуске, он не будет больше использоваться после завершения запуска.
    
4. **GSEventReceiveRunLoopMode**: внутренний режим для приема системных событий, обычно не используется.
    
5. **kCFRunLoopCommonModes**: это режим-заполнитель, не имеющий практического значения.

**Четыре функции цикла исполнения:**

- Принимать вводимые пользователем данные, не прерывая выполнения программы.
    
- Решать, когда события должны обрабатываться программой.
    
- Разделять вызовы.
    
- Экономить время процессора