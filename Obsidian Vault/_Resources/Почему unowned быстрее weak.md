#многопоточность
Причина, по которой `unowned` обычно быстрее, чем `weak` в Swift, заключается в механизме их работы и управлении памятью в контексте ARC (Automatic Reference Counting).

### Unowned References:

1. **Не Увеличивают и Не Уменьшают Счетчик Ссылок**: Когда вы используете `unowned`, счетчик сильных ссылок объекта не увеличивается. Это также означает, что при освобождении объекта, на который указывает `unowned` ссылка, счетчик ссылок не уменьшается.

2. **Не Обнуляются Автоматически**: В отличие от `weak`, `unowned` ссылки не обнуляются автоматически, когда объект, на который они указывают, освобождается. Это снижает накладные расходы на управление памятью.

3. **Меньше Накладных Расходов**: Поскольку `unowned` ссылки не требуют дополнительного управления (такого как обнуление или изменение счетчика ссылок), они могут быть более эффективными в плане производительности.

### Weak References:

1. **Увеличивают и Уменьшают Счетчик Слабых Ссылок**: Когда вы используете `weak`, это увеличивает счетчик слабых ссылок объекта. Когда объект освобождается, ARC должен обнулить все слабые ссылки, что требует дополнительных вычислений.

2. **Автоматически Обнуляются**: `Weak` ссылки автоматически обнуляются, когда объект, на который они указывают, удаляется. Это требует дополнительного управления и отслеживания со стороны ARC.

3. **Больше Накладных Расходов**: Из-за необходимости управления счетчиком слабых ссылок и автоматического обнуления, `weak` ссылки могут вносить больше накладных расходов по сравнению с `unowned`.

### Вывод:

Использование `unowned` может быть более эффективным по производительности из-за меньших накладных расходов, связанных с управлением ссылками. Однако важно помнить, что `unowned` следует использовать только тогда, когда вы уверены, что объект, на который она указывает, не будет освобожден, пока ссылка на него существует. В противном случае доступ к `unowned` ссылке после освобождения объекта приведёт к ошибке времени выполнения.